@startuml
title 订单二维码收款时序图
participant 商户App as merApp
participant 用户APP as app
participant 交易中心 as trade
participant redis
participant mq
participant 收银台 as cashier
participant 营销中心 as marketing
participant 凭证中心 as voucher

autonumber
merApp -> trade: 输入订单金额
activate trade
trade -> redis: 获取商户信息缓存
note left
若商户信息有改动，商户中心会发消息到mq，
这边监听到，且删除旧缓存并会查询最新的
信息更新到缓存保证缓存与数据库一致。（商
户中心那边也有缓存，为防止缓存雪崩，商户
中心那边的缓存失效时间和这边的错开，并用分
布式锁确保只有一个进程对重建缓存）
end note
activate redis
redis --> trade:
deactivate redis
trade -> trade: 商户检验
trade -> trade: 生成二维码(并把订单信息存入二维码中)
note left
在改造前，这一步是将订单入库，导致产生了大量
废单（因为很多订单没人支付），数据量剧增到500万+。
把订单信息存入二维码中的目的是利用客户端存储，
等到用户扫码时再把订单信息带过来，再入库。
end note
merApp <-- trade: 返回收款人信息和二维码
deactivate trade

app -> trade: 扫一扫
activate trade
trade -> trade: 解析二维码内容
trade -> trade: 获取订单信息(订单号,收款方,收银员,金额,币种)
trade -> mq: 把订单对象推到mq
note left
把订单对象推到mq，再异步入库的目的是削峰，
经测算，交易的峰值是2万TPS，而数据服务器
只有两台，能承受的并发写入是4000/s左右
end note
activate mq
trade <-- mq
deactivate mq
trade -> redis: 并把订单信息双写到缓存
note left
双写到缓存的目的是，有可能异步入库的速度
不够快（因为消息堆积等原因），用户真正支
付时找不到订单，这时就把缓存的订单先入库
end note
trade <-- redis
trade --> app: 返回订单信息

trade <-- mq
trade -> trade: 订单异步入库
deactivate trade

app -> trade: 确认支付并输入密码
activate trade
trade -> trade: 支付前置校验
trade -> trade: 风控校验
trade -> trade: 锁订单
alt 异步入库失败或速度慢
trade -> redis: 到缓存获取订单信息
redis --> trade
trade -> trade: 入库并锁单
end
trade -> cashier: 发起创建收银流水请求
note left
这步有可能是瓶颈，因为结果必须同步，
而效率取决于账户服务，所以这一步做了
降级和熔断处理，实现快速失败，并且做
了资源隔离，不会导致故障蔓延
end note
activate cashier
cashier -> cashier: 缓存支付工具
cashier -> voucher: 创建凭证
activate voucher
cashier <-- voucher: 返回凭证
deactivate voucher
cashier -> cashier: 创建流水(state:10)
trade <-- cashier: 返回收银流水
deactivate cashier
trade -> trade: 更新交易订单(state:10->11)
app <-- trade: 返回凭证号
deactivate trade

@enduml